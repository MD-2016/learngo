The purpose of this file is to take notes on import topics from the go language and TDD approach to programming. The goal is understand the go language to an extent of building more involved projects, understanding back-end web development more in depth, and understand Test Driven Development to be applied to future projects.

- GET is for getting information from a server where GET is the variable used in headers to signal getting information.
- POST is sending information to the server through the POST variable in the http header
- Follow the approach of Red, Green, Refactor for TDD where you do red for a test and it fails, green where you write minimal code to get it to work, then refactor to make it more optimized 
- For backend testing you'll need to create mocks of the process you're trying to acheieve with said code. This may include writing interfaces to build upon or building a spy for post results and stub to test GET calls
- ListenAndServe is commonly used to create a web server in go lang
- Go rountines are created for every request with ListenAndServe. This also means they are ran against a Handler which handles what happens with each request
- In order to test our server, we will need a Request to send in and we'll want to spy on what our handler writes to the ResponseWriter.
- We use http.NewRequest to create a request. The first argument is the request's method and the second is the request's path. The nil argument refers to the request's body, which we don't need to set in this case.
- net/http/httptest has a spy already made for us called ResponseRecorder so we can use that. It has many helpful methods to inspect what has been written as a response.
- net/http's ResponseWriter also implements io Writer so we can use fmt.Fprint to send strings as HTTP responses.
- Earlier we explored that the Handler interface is what we need to implement in order to make a server. Typically we do that by creating a struct and make it implement the interface by implementing its own ServeHTTP method. However the use-case for structs is for holding data but currently we have no state, so it doesn't feel right to be creating one.
-  HandlerFunc lets us avoid this. The HandlerFunc type is an adapter to allow the use of ordinary functions as HTTP handlers. If f is a function with the appropriate signature, HandlerFunc(f) is a Handler that calls f.
- type HandlerFunc has already implemented the ServeHTTP method. By type casting our PlayerServer function with it, we have now implemented the required Handler.
- ListenAndServe takes a port to listen on a Handler. If there is a problem the web server will return an error, an example of that might be the port already being listened to. For that reason we wrap the call in log.Fatal to log the error to the user.
- r.URL.Path returns the path of the request which we can then use strings.TrimPrefix  to trim away /players/ to get the requested player. It's not very robust but will do the trick for now.
- Stubs are good for making tests to pass get tests
- Can use http.Request to extract values from URL by trimming path with strings.Trim(Prefix / Postfix / etc)
- Integration tests can be useful for testing that larger areas of your system work but you must bear in mind:
  They are harder to write
  When they fail, it can be difficult to know why (usually it's a bug within a component of the integration test) and so can be harder to fix
  They are sometimes slower to run (as they often are used with "real" components, like a database)
- if on Linux, can use curl to change values in post and check get values
- Use http.HandlerFunc to turn ordinary functions into http.Handlers
- http.Handler implement this interface to create web servers
- Use httptest.NewRecorder to pass in as a ResponseWriter to let you spy on the responses your handler sends
- Use http.NewRequest to construct the requests you expect to come in to your system
- Go has a built-in routing mechanism called ServeMux (request multiplexer) which lets you attach http.Handlers to particular request paths.
- We changed the second property of PlayerServer, removing the named property router http.ServeMux and replaced it with http.Handler; this is called embedding.
- Go does not provide the typical, type-driven notion of subclassing, but it does have the ability to “borrow” pieces of an implementation by embedding types within a struct or interface.
- You must be careful with embedding types because you will expose all public methods and fields of the type you embed. In our case, it is ok because we embedded just the interface that we wanted to expose (http.Handler).
- If we had been lazy and embedded http.ServeMux instead (the concrete type) it would still work but users of PlayerServer would be able to add new routes to our server because Handle(path, handler) would be public.
- When embedding types, really think about what impact that has on your public API.
- It is a very common mistake to misuse embedding and end up polluting your APIs and exposing the internals of your type.
- To parse JSON into our data model we create a Decoder from encoding/json package and then call its Decode method. To create a Decoder it needs an io.Reader to read from which in our case is our response spy's Body
- Decode takes the address of the thing we are trying to decode into which is why we declare an empty slice of Player the line before.
- Parsing JSON can fail so Decode can return an error. There's no point continuing the test if that fails so we check for the error and stop the test with t.Fatalf if it happens. Notice that we print the response body along with the error as it's important for someone running the test to see what string cannot be parsed.
- To create an Encoder you need an io.Writer which is what http.ResponseWriter implements.
- To create a Decoder you need an io.Reader which the Body field of our response spy implements.
- Routing. The standard library offers you an easy to use type to do routing. It fully embraces the http.Handler interface in that you assign routes to Handlers and the router itself is also a Handler. It does not have some features you might expect though such as path variables (e.g /users/{id}). You can easily parse this information yourself but you might want to consider looking at other routing libraries if it becomes a burden. Most of the popular ones stick to the standard library's philosophy of also implementing http.Handler.
- Type embedding. We touched a little on this technique but you can . If there is one thing you should take away from this is that it can be extremely useful but always thinking about your public API, only expose what's appropriate.
- JSON deserializing and serializing. The standard library makes it very trivial to serialise and deserialise your data. It is also open to configuration and you can customise how these data transformations work if necessary.
- 
