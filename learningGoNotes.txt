The purpose of this file is to take notes on import topics from the go language and TDD approach to programming. The goal is understand the go language to an extent of building more involved projects, understanding back-end web development more in depth, and understand Test Driven Development to be applied to future projects.

- GET is for getting information from a server where GET is the variable used in headers to signal getting information.
- POST is sending information to the server through the POST variable in the http header
- Follow the approach of Red, Green, Refactor for TDD where you do red for a test and it fails, green where you write minimal code to get it to work, then refactor to make it more optimized 
- For backend testing you'll need to create mocks of the process you're trying to acheieve with said code. This may include writing interfaces to build upon or building a spy for post results and stub to test GET calls
- ListenAndServe is commonly used to create a web server in go lang
- Go rountines are created for every request with ListenAndServe. This also means they are ran against a Handler which handles what happens with each request
- In order to test our server, we will need a Request to send in and we'll want to spy on what our handler writes to the ResponseWriter.
- We use http.NewRequest to create a request. The first argument is the request's method and the second is the request's path. The nil argument refers to the request's body, which we don't need to set in this case.
- net/http/httptest has a spy already made for us called ResponseRecorder so we can use that. It has many helpful methods to inspect what has been written as a response.
- net/http's ResponseWriter also implements io Writer so we can use fmt.Fprint to send strings as HTTP responses.
- Earlier we explored that the Handler interface is what we need to implement in order to make a server. Typically we do that by creating a struct and make it implement the interface by implementing its own ServeHTTP method. However the use-case for structs is for holding data but currently we have no state, so it doesn't feel right to be creating one.
-  HandlerFunc lets us avoid this. The HandlerFunc type is an adapter to allow the use of ordinary functions as HTTP handlers. If f is a function with the appropriate signature, HandlerFunc(f) is a Handler that calls f.
- type HandlerFunc has already implemented the ServeHTTP method. By type casting our PlayerServer function with it, we have now implemented the required Handler.
- ListenAndServe takes a port to listen on a Handler. If there is a problem the web server will return an error, an example of that might be the port already being listened to. For that reason we wrap the call in log.Fatal to log the error to the user.
- r.URL.Path returns the path of the request which we can then use strings.TrimPrefix  to trim away /players/ to get the requested player. It's not very robust but will do the trick for now.
- Stubs are good for making tests to pass get tests
- Can use http.Request to extract values from URL by trimming path with strings.Trim(Prefix / Postfix / etc)
- Integration tests can be useful for testing that larger areas of your system work but you must bear in mind:
  They are harder to write
  When they fail, it can be difficult to know why (usually it's a bug within a component of the integration test) and so can be harder to fix
  They are sometimes slower to run (as they often are used with "real" components, like a database)
- if on Linux, can use curl to change values in post and check get values
- Use http.HandlerFunc to turn ordinary functions into http.Handlers
- http.Handler implement this interface to create web servers
- Use httptest.NewRecorder to pass in as a ResponseWriter to let you spy on the responses your handler sends
- Use http.NewRequest to construct the requests you expect to come in to your system
- Go has a built-in routing mechanism called ServeMux (request multiplexer) which lets you attach http.Handlers to particular request paths.
- We changed the second property of PlayerServer, removing the named property router http.ServeMux and replaced it with http.Handler; this is called embedding.
- Go does not provide the typical, type-driven notion of subclassing, but it does have the ability to “borrow” pieces of an implementation by embedding types within a struct or interface.
- You must be careful with embedding types because you will expose all public methods and fields of the type you embed. In our case, it is ok because we embedded just the interface that we wanted to expose (http.Handler).
- If we had been lazy and embedded http.ServeMux instead (the concrete type) it would still work but users of PlayerServer would be able to add new routes to our server because Handle(path, handler) would be public.
- When embedding types, really think about what impact that has on your public API.
- It is a very common mistake to misuse embedding and end up polluting your APIs and exposing the internals of your type.
- To parse JSON into our data model we create a Decoder from encoding/json package and then call its Decode method. To create a Decoder it needs an io.Reader to read from which in our case is our response spy's Body
- Decode takes the address of the thing we are trying to decode into which is why we declare an empty slice of Player the line before.
- Parsing JSON can fail so Decode can return an error. There's no point continuing the test if that fails so we check for the error and stop the test with t.Fatalf if it happens. Notice that we print the response body along with the error as it's important for someone running the test to see what string cannot be parsed.
- To create an Encoder you need an io.Writer which is what http.ResponseWriter implements.
- To create a Decoder you need an io.Reader which the Body field of our response spy implements.
- Routing. The standard library offers you an easy to use type to do routing. It fully embraces the http.Handler interface in that you assign routes to Handlers and the router itself is also a Handler. It does not have some features you might expect though such as path variables (e.g /users/{id}). You can easily parse this information yourself but you might want to consider looking at other routing libraries if it becomes a burden. Most of the popular ones stick to the standard library's philosophy of also implementing http.Handler.
- Type embedding. We touched a little on this technique but you can . If there is one thing you should take away from this is that it can be extremely useful but always thinking about your public API, only expose what's appropriate.
- JSON deserializing and serializing. The standard library makes it very trivial to serialise and deserialise your data. It is also open to configuration and you can customise how these data transformations work if necessary.
- We're using strings.NewReader which will return us a Reader, which is what our FileSystemPlayerStore will use to read data. In main we will open a file, which is also a Reader.
- Seek is used to move through files whether it be to the end or to the beginning
- os.File has a truncate function that will let us effectively empty the file.
- We started off the code by using io.Reader as that was the easiest path for us to unit test our new PlayerStore. As we developed the code we moved on to io.ReadWriter and then io.ReadWriteSeeker. We then found out there was nothing in the standard library that actually implemented that apart from *os.File. We could've taken the decision to write our own or use an open source one but it felt pragmatic just to make temporary files for the tests.
- Finally, we needed Truncate which is also on *os.File. It would've been an option to create our own interface capturing these requirements.
- file.Stat returns stats on our file, which lets us check the size of the file. If it's empty, we Write an empty JSON array and Seek back to the start, ready for the rest of the code.
- sort.Slice is a good way of sorting slices
- We'll use a bufio.Scanner to read the input from the io.Reader
- Package bufio implements buffered I/O. It wraps an io.Reader or io.Writer object, creating another object (Reader or Writer) that also implements the interface but provides buffering and some help for textual I/O.
- Scanner.Scan() will read up to a newline.
- We then use Scanner.Text() to return the string the scanner read to.
- We saw how reading from os.Stdin is very easy for us to work with as it implements io.Reader. We used bufio.Scanner to easily read line by line user input.
- AfterFunc waits for the duration to elapse and then calls f in its own goroutine. It returns a Timer that can be used to cancel the call using its Stop method.
- time.Duration A Duration represents the elapsed time between two instants as an int64 nanosecond count.
- Remember that any type can implement an interface, not just structs. If you are making a library that exposes an interface with one function defined it is a common idiom to also expose a MyInterfaceFunc type.
- This type will be a func which will also implement your interface. That way users of your interface have the option to implement your interface with just a function; rather than having to create an empty struct type.
- We use cli.readLine() to get the input from the user and then call Atoi to convert it into an integer - ignoring any error scenarios. We'll need to write a test for that scenario later.
- In order to test that we are scheduling some alerts we set up 4 different dependencies. Whenever you have a lot of dependencies for a thing in your system, it implies it's doing too much. Visually we can see it in how cluttered our test is.
- A very handy way of scheduling a function call after a specific duration. It is well worth investing time looking at the documentation for time  as it has a lot of time saving functions and methods for you to work with.
- time.After(duration) returns a chan Time when the duration has expired. So if you wish to do something after a specific time, this can help.
- time.NewTicker(duration) returns a Ticker which is similar to the above in that it returns a channel but this one "ticks" every duration, rather than just once. This is very handy if you want to execute some code every N duration
- First we will need to serve HTML. So far all of our HTTP endpoints have returned either plaintext or JSON. We could use the same techniques we know (as they're all ultimately strings) but we can also use the html/template package for a cleaner solution.
- WebSocket is a computer communications protocol, providing full-duplex communication channels over a single TCP connection
- Write a browser based test, using something like Selenium. These tests are the most "realistic" of all approaches because they start an actual web browser of some kind and simulates a user interacting with it. These tests can give you a lot of confidence your system works but are more difficult to write than unit tests and much slower to run. For the purposes of our product this is overkill.
- Do an exact string match. This can be ok but these kind of tests end up being very brittle. The moment someone changes the markup you will have a test failing when in practice nothing has actually broken.
- Check we call the correct template. We will be using a templating library from the standard lib to serve the HTML (discussed shortly) and we could inject in the thing to generate the HTML and spy on its call to check we're doing it right. This would have an impact on our code's design but doesn't actually test a great deal; other than we're calling it with the correct template file. Given we will only have the one template in our project the chance of failure here seems low.
- html/template is a Go package for creating HTML. In our case we call template.ParseFiles, giving the path of our html file. Assuming there is no error you can then Execute the template, which writes it to an io.Writer. In our case we want it to Write to the internet, so we give it our http.ResponseWriter.
- Our previous tests around our server just called methods on our server but now we need to have a persistent connection to our server. To do that we use httptest.NewServer which takes a http.Handler and will spin it up and listen for connections.
- Using websocket.DefaultDialer.Dial we try to dial in to our server and then we'll try and send a message with our winner.
- conn.ReadMessage() blocks on waiting for a message on the connection. Once we get one we use it to RecordWin. This would finally close the WebSocket connection.
- The issue is timing. There is a delay between our WebSocket connection reading the message and recording the win and our test finishes before it happens. You can test this by putting a short time.Sleep before the final assertion.
- We are not going to send the blind messages anywhere just yet as we need to have a think about that. When we call game.Start we send in io.Discard which will just discard any messages written to it.
- It uses exec.Command which allows you to execute an external command to the process
- We capture the output in cmd.StdoutPipe which returns us a io.ReadCloser (this will become important)
- In this case we are using errors.As to try and extract our error into our custom type. It returns a bool to denote success and extracts it into got for us.
- The HandlerFunc type is an adapter to allow the use of ordinary functions as HTTP handlers for http.HandleFunc
- http.Request which is just a bundle of data for us to inspect, parse and validate.
- A http.ResponseWriter interface is used by an HTTP handler to construct an HTTP response

# Go Important Topics

- It is sometimes useful to also print the inputs to the function in the error message. Here, we are using the %v placeholder to print the "default" format, which works well for arrays.
- range lets you iterate over an array. On each iteration, range returns two values - the index and the value. We are choosing to ignore the index value by using _ black identifier
- We will now use the slice type which allows us to have collections of any size. The syntax is very similar to arrays, you just omit the size when declaring them
- Go does not let you use equality operators with slices. You could write a function to iterate over each got and want slice and check their values but for convenience sake, we can use reflect.DeepEqual  which is useful for seeing if any two variables are the same.
- t's important to note that reflect.DeepEqual is not "type safe" - the code will compile even if you did something a bit silly. To see this in action, temporarily change the test to:
- What we have done here is try to compare a slice with a string. This makes no sense, but the test compiles! So while using reflect.DeepEqual is a convenient way of comparing slices (and other things) you must be careful when using it.
- There's a new way to create a slice. make allows you to create a slice with a starting capacity of the len of the numbersToSum we need to work through.
- You can index slices like arrays with mySlice[N] to get the value out or assign it a new value with =
- Slices can be sliced! The syntax is slice[low:high]. If you omit the value on one of the sides of the : it captures everything to that side of it. In our case, we are saying "take from 1 to the end" with numbers[1:]. You may wish to spend some time writing other tests around slices and experiment with the slice operator to get more familiar with it.
- Slices
	The various ways to make them
	How they have a fixed capacity but you can create new slices from old ones using append
	How to slice, slices!
- len to get the length of an array or slice
- reflect.DeepEqual and why it's useful but can reduce the type-safety of your code
- A method is a function with a receiver. A method declaration binds an identifier, the method name, to a method, and associates the method with the receiver's base type.
- Interfaces are a very powerful concept in statically typed languages like Go because they allow you to make functions that can be used with different types and create highly-decoupled code whilst still maintaining type-safety.
- Pointers  let us point to some values and then let us change them. 
- We've introduced t.Fatal which will stop the test if it is called. This is because we don't want to make any more assertions on the error returned if there isn't one around. Without this the test would carry on to the next step and panic because of a nil pointer
- Go copies values when you pass them to functions/methods, so if you're writing a function that needs to mutate state you'll need it to take a pointer to the thing you want to change.
- The fact that Go takes a copy of values is useful a lot of the time but sometimes you won't want your system to make a copy of something, in which case you need to pass a reference. Examples include referencing very large data structures or things where only one instance is necessary (like database connection pools).
- Pointers can be nil
- When a function returns a pointer to something, you need to make sure you check if it's nil or you might raise a runtime exception - the compiler won't help you here.
- nil Useful for when you want to describe a value that could be missing
- Errors are the way to signify failure when calling a function/method.
- By listening to our tests we concluded that checking for a string in an error would result in a flaky test. So we refactored our implementation to use a meaningful value instead and this resulted in easier to test code and concluded this would be easier for users of our API too.
- Create new types from existing ones. Useful for adding more domain specific meaning to values, Can let you implement interfaces
- To tell Go to start a new goroutine we turn a function call into a go statement by putting the keyword go in front of it: go doSomething().
 - We can solve this data race by coordinating our goroutines using channels. Channels are a Go data structure that can both receive and send values. These operations, along with their details, allow communication between different processes. 
- goroutines, the basic unit of concurrency in Go, which let us check more than one website at the same time.
- anonymous functions, which we used to start each of the concurrent processes that check websites.
- channels, to help organize and control the communication between the different processes, allowing us to avoid a race condition bug.
- the race detector which helped us debug problems with concurrent code
- We use time.Now() to record just before we try and get the URL.
- Then we use http.Get to try and perform an HTTP GET request against the URL. This function returns an http.Response and an error but so far we are not interested in these values.
- time.Since takes the start time and returns a time.Duration of the difference.
- In the standard library, there is a package called net/http/httptest which enables users to easily create a mock HTTP server.
- httptest.NewServer takes an http.HandlerFunc which we are sending in via an anonymous function.
- http.HandlerFunc is a type that looks like this: type HandlerFunc func(ResponseWriter, *Request).
- It turns out there's really no extra magic here, this is also how you would write a real HTTP server in Go. The only difference is we are wrapping it in an httptest.NewServer which makes it easier to use with testing, as it finds an open port to listen on and then you can close it when you're done with your test.
- Inside our two servers, we make the slow one have a short time.Sleep when we get a request to make it slower than the other one. Both servers then write an OK response with w.WriteHeader(http.StatusOK) back to the caller.
- By prefixing a function call with defer it will now call that function at the end of the containing function.
- Sometimes you will need to clean up resources, such as closing a file or in our case closing a server so that it does not continue to listen to a port.
- You want this to execute at the end of the function, but keep the instruction near where you created the server for the benefit of future readers of the code.
- Why struct{} and not another type like a bool? Well, a chan struct{} is the smallest data type available from a memory perspective so we get no allocation versus a bool. Since we are closing and not sending anything on the chan, why allocate anything? 
- Notice how we have to use make when creating a channel; rather than say var ch chan struct{}. When you use var the variable will be initialised with the "zero" value of the type. So for string it is "", int it is 0, etc.
 - Always make channels
 - For channels the zero value is nil and if you try and send to it with <- it will block forever because you cannot send to nil channels
 - select: Helps you wait on multiple channels. Sometimes you'll want to include time.After in one of your cases to prevent your system blocking forever
 - httptest: A convenient way of creating test servers so you can have reliable and controllable tests. Uses the same interfaces as the "real" net/http servers which is consistent and less for you to learn.
- Reflection in computing is the ability of a program to examine its own structure, particularly through types; it's a form of metaprogramming. It's also a great source of confusion.
- Go lets us get around this with the type interface{} which you can think of as just any type (in fact, in Go any is an alias for interface{} 
- As a user of a function that takes interface{} you lose type safety. What if you meant to pass Herd.species of type string into a function but instead did Herd.count which is an int? The compiler won't be able to inform you of your mistake. You also have no idea what you're allowed to pass to a function. Knowing that a function takes a UserService for instance is very useful.
- As a writer of such a function, you have to be able to inspect anything that has been passed to you and try and figure out what the type is and what you can do with it. This is done using reflection. This can be quite clumsy and difficult to read and is generally less performant (as you have to do checks at runtime).
- The reflect package  has a function ValueOf which returns us a Value of a given variable. This has ways for us to inspect a value, including its fields which we use on the next line.
- Now that you know about reflection, do your best to avoid using it.
- sync.WaitGroup which is a convenient way of synchronising concurrent processes. A WaitGroup waits for a collection of goroutines to finish. The main goroutine calls Add to set the number of goroutines to wait for. Then each of the goroutines runs and calls Done when finished. At the same time, Wait can be used to block until all goroutines have finished. 
- A simple solution is to add a lock to our Counter, ensuring only one goroutine can increment the counter at a time. Go's mutex provides such a lock: A Mutex is a mutual exclusion lock. The zero value for a Mutex is an unlocked mutex.
- Mutex allows us to add locks to our data
- WaitGroup is a means of waiting for goroutines to finish jobs
- The context package provides functions to derive new Context values from existing ones. These values form a tree: when a Context is canceled, all Contexts derived from it are also canceled.
- What we do is derive a new cancellingCtx from our request which returns us a cancel function. We then schedule that function to be called in 5 milliseconds by using time.AfterFunc. Finally we use this new context in our request by calling request.WithContext.
- context has a method Done() which returns a channel which gets sent a signal when the context is "done" or "cancelled". We want to listen to that signal and call store.Cancel if we get it but we want to ignore it if our Store manages to Fetch before it.
- To manage this we run Fetch in a goroutine and it will write the result into a new channel data. We then use select to effectively race to the two asynchronous processes and then we either write a response or Cancel.
- Incoming requests to a server should create a Context, and outgoing calls to servers should accept a Context. The chain of function calls between them must propagate the Context, optionally replacing it with a derived Context created using WithCancel, WithDeadline, WithTimeout, or WithValue. When a Context is canceled, all Contexts derived from it are also canceled.
- At Google, we require that Go programmers pass a Context parameter as the first argument to every function on the call path between incoming and outgoing requests. This allows Go code developed by many different teams to interoperate well. It provides simple control over timeouts and cancelation and ensures that critical values like security credentials transit Go programs properly.
- The problem with context.Values is that it's just an untyped map so you have no type-safety and you have to handle it not actually containing your value. You have to create a coupling of map keys from one module to another and if someone changes something things start breaking.
- In short, if a function needs some values, put them as typed parameters rather than trying to fetch them from context.Value. This makes it statically checked and documented for everyone to see.
- n terms of constraints, any does mean "anything" and so does interface{}. In fact, any was added in 1.18 and is just an alias for interface{}.
- The request handler alone can not accept any HTTP connections from the outside. An HTTP server has to listen on a port to pass connections on to the request handler. Because port 80 is in most cases the default port for HTTP traffic, this server will also listen on it. The following code will start Go’s default HTTP server and listen for connections on port 80. You can navigate your browser to http://localhost/ and see your server handing your request. Use http.ListenAndServe()
- The net/http package contains all utilities needed to accept requests and handle them dynamically. We can register a new handler with the http.HandleFunc function. It’s first parameter takes a path to match and a function to execute as a second. In this example: When someone browses your websites (http://example.com/), he or she will be greeted with a nice message.
- For the dynamic aspect, the http.Request contains all information about the request and it’s parameters. You can read GET parameters with r.URL.Query().Get("token") or POST parameters (fields from an HTML form) with r.FormValue("email").
- To serve static assets like JavaScript, CSS and images, we use the inbuilt http.FileServer and point it to a url path. For the file server to work properly it needs to know, where to serve files from. 
- Once our file server is in place, we just need to point a url path at it, just like we did with the dynamic requests. One thing to note: In order to serve files correctly, we need to strip away a part of the url path. Usually this is the name of the directory our files live in. 
- The last thing to finish off our basic HTTP server is, to listen on a port to accept connections from the internet. As you can guess, Go has also an inbuilt HTTP server, we can start faily quickly. Once started, you can view your HTTP server in your browser.
- Go’s net/http package provides a lot of functionalities for the HTTP protocol. One thing it doesn’t do very well is complex request routing like segmenting a request url into single parameters. Fortunately there is a very popular package for this, which is well known for the good code quality in the Go community. In this example you will see how to use the gorilla/mux package to create routes with named parameters, GET/POST handlers and domain restrictions.
- gorilla/mux is a package which adapts to Go’s default HTTP router. It comes with a lot of features to increase the productivity when writing web applications. It is also compliant to Go’s default request handler signature func (w http.ResponseWriter, r *http.Request), so the package can be mixed and machted with other HTTP libraries like middleware or exisiting applications. Use the go get command to install the package from GitHub like so:
- First create a new request router. The router is the main router for your web application and will later be passed as parameter to the server. It will receive all HTTP connections and pass it on to the request handlers you will register on it. 
- Once you have a new router you can register request handlers like usual. The only difference is, that instead of calling http.HandleFunc(...), you call HandleFunc on your router like this: r.HandleFunc(...).
- The biggest strength of the gorilla/mux Router is the ability to extract segments from the request URL. 
- The last thing is to get the data from these segments. The package comes with the function mux.Vars(r) which takes the http.Request as parameter and returns a map of the segments.
- Ever wondered what the nil in http.ListenAndServe(":80", nil) ment? It is the parameter for the main router of the HTTP server. By default it’s nil, which means to use the default router of the net/http package. To make use of your own router, replace the nil with the variable of your router r. 
- Restrict the request handler to specific hostnames or subdomains using .HandleFunc().Host()
- Restrict the request handler to http/https. using .Schemes()
- Restrict the request handler to specific path prefixes with Subrouter()
- The Go programming language comes with a handy package called `database/sql` to query all sorts of SQL databases. This is useful as it abstracts all common SQL features into a single API for you to use. What Go does not include is are database drivers. In Go, database driver is a package which implements the low level details of a specific database (in our case MySQL). As you might have already guessed, this is useful to stay forward compatible. Since, at the time of creating all Go packages, the authors cannot foresee every single database coming to live in the future and supporting every possible database out there would be a large amount of maintenance work.
- The first thing we need to check after installing all necessary packages is, if we can connect to our MySQL database successfully. If you don’t have a MySQL database server already running, you can start a new instance with Docker easily. Here are the official docs for the Docker MySQL image: https://hub.docker.com/_/mysql. To check if we can connect to our database, import the database/sql and the go-sql-driver/mysql package and open up a connection like so:
- Now that we have a user in our table, we want to query it and get back all of its information. In Go we have two possibilities to query our tables. There is db.Query which can query multiple rows, for us to iterate over and there is db.QueryRow in case we only want to query a specific row. Querying a specific row works basically like every other SQL command we’ve covered before. Our SQL command to query one single user by its ID 
- Go’s html/template package provides a rich templating language for HTML templates. It is mostly used in web applications to display data in a structured way in a client’s browser. One great benefit of Go’s templating language is the automatic escaping of data. There is no need to worry about XSS attacks as Go parses the HTML template and escapes all inputs before displaying it to the browser.
- Writing a template in Go is very simple. This example shows a TODO list, written as an unordered list (ul) in HTML. When rendering templates, the data passed in can be any kind of Go’s data structures. It may be a simple string or a number, it can even be nested data structure as in the example below. To access the data in a template the top most variable is access by {{.}}. The dot inside the curly braces is called the pipeline and the root element of the data.
- The templating language contains a rich set of control structures to render your HTML. Here you will get an overview of the most commonly used ones. To get a detailed list of all possible structures visit: text/template
- Template can either be parsed from a string or a file on disk. As it is usually the case, that templates are pares from disk, this example shows how to do so. In this example there is a template file in the same directory as the Go program called layout.html.
- Once the template is parsed from disk it’s ready to be used in the request handler. The Execute function accepts an io.Writer for writing out the template and an interface{} to pass data into the template. When the function is called on an http.ResponseWriter the Content-Type is header is automatically set in the HTTP response to Content-Type: text/html; charset=utf-8.
- use http.FileServer(http.Dir("")) to serve static files then pass through http.Handle()
- This example will show how to create basic logging middleware in Go. A middleware simply takes a http.HandlerFunc as one of its parameters, wraps it and returns a new http.HandlerFunc for the server to call.
- This example will show how to create a more advanced version of middleware in Go. A middleware in itself simply takes a http.HandlerFunc as one of its parameters, wraps it and returns a new http.HandlerFunc for the server to call. Here we define a new type Middleware which makes it eventually easier to chain multiple middlewares together. This idea is inspired by Mat Ryers’ talk about Building APIs. You can find a more detailed explaination including the talk here. This snippet explains in detail how a new middleware is created. In the full example below, we reduce this version by some boilerplate code.
- This example will show how to store data in session cookies using the popular gorilla/sessions package in Go. Cookies are small pieces of data stored in the browser of a user and are sent to our server on each request. In them, we can store e.g. whether or not a user is logged in into our website and figure out who he actually is (in our system). In this example we will only allow authenticated users to view our secret message on the /secret page. To get access to it, the will first have to visit /login to get a valid session cookie, which logs him in. Additionally he can visit /logout to revoke his access to our secret message.
- This example will show how to hash passwords using bcrypt. For this we have to go get the golang bcrypt library like so: go get golang.org/x/crypto/bcrypt From now on, every application we write will be able to make use of this library.
- Channels are the pipes that connect concurrent goroutines. You can send values into channels from one goroutine and receive those values into another goroutine. 
- Send a value into a channel using the channel <- syntax. Here we send "ping" to the messages channel we made above, from a new goroutine.
- The <-channel syntax receives a value from the channel. 
- By default channels are unbuffered, meaning that they will only accept sends (chan <-) if there is a corresponding receive (<- chan) ready to receive the sent value. Buffered channels accept a limited number of values without a corresponding receiver for those values.
- We can use channels to synchronize execution across goroutines. Here’s an example of using a blocking receive to wait for a goroutine to finish. When waiting for multiple goroutines to finish, you may prefer to use a WaitGroup.
- When using channels as function parameters, you can specify if a channel is meant to only send or receive values. This specificity increases the type-safety of the program.
- Go’s select lets you wait on multiple channel operations. Combining goroutines and channels with select is a powerful feature of Go.
- Timeouts are important for programs that connect to external resources or that otherwise need to bound execution time. Implementing timeouts in Go is easy and elegant thanks to channels and select.
- Here’s the select implementing a timeout. res := <-c1 awaits the result and <-time.After awaits a value to be sent after the timeout of 1s. Since select proceeds with the first receive that’s ready, we’ll take the timeout case if the operation takes more than the allowed 1s.
- Basic sends and receives on channels are blocking. However, we can use select with a default clause to implement non-blocking sends, receives, and even non-blocking multi-way selects.
- Closing a channel indicates that no more values will be sent on it. This can be useful to communicate completion to the channel’s receivers.
- In a previous example we saw how for and range provide iteration over basic data structures. We can also use this syntax to iterate over values received from a channel.
- We often want to execute Go code at some point in the future, or repeatedly at some interval. Go’s built-in timer and ticker features make both of these tasks easy. We’ll look first at timers and then at tickers.
- Timers are for when you want to do something once in the future - tickers are for when you want to do something repeatedly at regular intervals. Here’s an example of a ticker that ticks periodically until we stop it.
- Tickers use a similar mechanism to timers: a channel that is sent values.
- In this example we’ll look at how to implement a worker pool using goroutines and channels.
- Here’s the worker, of which we’ll run several concurrent instances. These workers will receive work on the jobs channel and send the corresponding results on results. We’ll sleep a second per job to simulate an expensive task.
- To wait for multiple goroutines to finish, we can use a wait group.
- This WaitGroup is used to wait for all the goroutines launched here to finish. Note: if a WaitGroup is explicitly passed into functions, it should be done by pointer.
- Wrap the worker call in a closure that makes sure to tell the WaitGroup that this worker is done. This way the worker itself does not have to be aware of the concurrency primitives involved in its execution.
- Rate limiting is an important mechanism for controlling resource utilization and maintaining quality of service. Go elegantly supports rate limiting with goroutines, channels, and tickers.
- The primary mechanism for managing state in Go is communication over channels. We saw this for example with worker pools. There are a few other options for managing state though. Here we’ll look at using the sync/atomic package for atomic counters accessed by multiple goroutines.
- In the previous example we saw how to manage simple counter state using atomic operations. For more complex state we can use a mutex to safely access data across multiple goroutines.
- In the previous example we used explicit locking with mutexes to synchronize access to shared state across multiple goroutines. Another option is to use the built-in synchronization features of goroutines and channels to achieve the same result. This channel-based approach aligns with Go’s ideas of sharing memory by communicating and having each piece of data owned by exactly 1 goroutine.
- For this particular case the goroutine-based approach was a bit more involved than the mutex-based one. It might be useful in certain cases though, for example where you have other channels involved or when managing multiple such mutexes would be error-prone. You should use whichever approach feels most natural, especially with respect to understanding the correctness of your program.
- 
